# A Dialectical View of Software Development

No question plagues the mind of a caring developer more than the question of how to best organize and coordinate software development.
The Agile Manifesto was published more than fifteen years ago and its steadily losing its status as a catchall answer for this very question.

It's critics point out as evidence of the manifesto's flaws that its application tends to generate a proliferation of manager types, and also a stream of pointless meetings that feel like bikeshedding (https://en.wiktionary.org/wiki/bikeshedding). However, the extent that we can attribute these flaws to the methodology itself or to other factors like Price's law (https://en.wikipedia.org/wiki/Derek_J._de_Solla_Price) - which tells us that 50% of productivity comes from the square root of the number of people doing the taks - is unknown.

As it is the case with any dying ideology, the thing that tends to occupy its absence is a form of nihilism, a call for a complete lack of structure, or extreme forms of subjectivism, where the developer become the sole arbiter of the relevant questions - although the claims of the uniqueness of the situation that he finds himself in and the peculiarities of a project seem often overblown and exaggerated, leading one to conclude that no relevant information can be drawn from the pool of collective knowledge of software development. This belief must be self evidently absurd.

While we wait for the next ideological cycle to begin, I would like to place my bets on what I am calling the **Dialectical View of Software Development** for the next big idea that will take it's place. Now, I know that _some_ people are not impressed by fancy-sounding names, so I am going to do my best to break this thing up and explain what I mean.

The term *dialectical* is most recognized in the work of a XIX century influent philosopher called Georg Wilhelm Friedrich Hegel. Hegel had a lot of interesting ideas, but certainly one of the most interesting ones is that the History moves forward through a process he called dialectic. In the dialectic process, firstly we have an idea pitched forward - the *thesis*. A thesis can be a religion, a form of government or simply the dominance of a particular culture over others. Over time, critics of the thesis start to gather and form their own set of beliefs that Hegel calls *antithesis*. The cool part about Hegel's insight is that he realized that what comes out from the intense disputes between the thesis and the anti-thesis is *neither* of them, but it's a combination of both, or the *synthesis* that embodies the best parts of each of them.

Software Development was always marked by the conflict of two different parties with seemingly different interests. On one hand, we have the client - the software investor - who would like to see the maximum amount of working features being churned out per unit of time. On the other hand, we have the developers who, lacking most of the information about the business, tends to place emphasis on careful design and the best practices. It's interesting to note that both of them have the same _goal_ - deliver of high-value software. They differ on which particular path to take along the way to reach this goal.

Instead of dreading this source of conflict, a dialectical view of software development understands that both parties: thesis and anti-thesis, have valuable insight to contribute in order to produce the best synthesis possible. In this view, the role of the developer becomes the role of the defender of the thesis of good practices **BUT** with the expectation that his beliefs will be challenged by the antithesis, the client.

What comes out of this whole process will hopefully be better than going to either extreme.
