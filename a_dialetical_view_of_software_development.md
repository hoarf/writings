No question plagues the mind of a caring developer more than the question of how to best organize and coordinate software development.
The Agile Manifesto was published more than fifteen years ago and its steadily losing its status as a catchall answer for this very question.

Critics of it point out as evidence of its flaws that it tends to generate a proliferation of manager types, besides an incessant stream of pointless meetings and a lot of bikeshedding. However, the extent that we can attribute these flaws to the methodology itself or to other factors like Price's law (https://en.wikipedia.org/wiki/Derek_J._de_Solla_Price) is unknown.

As it is the case with any dying ideology, the thing that tends to occupy its absence is a form of nihilism, a call for a complete lack of structure, or extreme forms of subjectivism, where the developer become the sole arbiter of the relevant questions - although the claims of the uniqueness of the situation and the peculiarities of a project seem often overblown and exaggerated, leading one to conclude that no relevant information can be drawn from the pool of collective knowledge of software development. This must be self evidently absurd.

While we wait for the next ideological cycle to begin, I would like to place my bets on what I am calling the **Dialectical View of Software Development** for the next big idea. Now, I know that _some_ people are not impressed by fancy-sounding names, so I am going to try to break this thing apart.

The term *dialectical* is most recognized in the work of a XIX century influent philosopher called Georg Wilhelm Friedrich Hegel. Hegel had a lot of interesting ideas, but certainly one of the most interesting ones is that the History moves forward through a process he called dialectic. In the dialectic process, firstly we have an idea pitched forward - the *thesis*. A thesis can be a religion, a form of government or simply the dominance of a particular culture over others. Over time, critics of the thesis start to gather and form their own set of beliefs that Hegel calls *antithesis*. The cool part about Hegel's insight is that he realized that what comes out from the intense disputes between the thesis and the anti-thesis is *neither* of them, but it's a combination of both the *synthesis*, that embodies the best parts of them both.

Software Development was always marked by the conflict of two different parties with a different interest. On one hand, we have the client - the software investor - who would like to see the maximum amount of working features being churned out per unit of time. On the other hand, we have the developers who, lacking most of the information about the business, tends to place emphasis on careful design and the best practices that he was able to learn. It's interesting to note that both of them have the same _goal_ - deliver of high-quality software - the differ on what particular path to take along the way to reach this goal.

Instead of dreading this source of conflict, a dialectical view of software development understands that both parties thesis and anti-thesis, have valuable insight to contribute in order to produce the best synthesis possible. In this view, the role of the developer becomes the role of the defender of the thesis of good practices **BUT** with the expectation that his beliefs will be challenged by the antithesis, the client.

What comes out of this whole process will hopefully be better than going to either extreme.

So, what evidence is there that this is a good idea on how to handle software craftsmanship at all? 

As it is with most of commonly held belief in the field, there is very little empirical research on this. However, if we think of the problem of finding the best mode of producing software in the manifold of every possible way to do so, we can view software development as an optimization problem and we can begin to trace similarities with adversarial optimization techniques, such as GAN - Generative Adversarial Networks, that currently enjoy a lot of hype in the AI world. 

One may think that I am stretching this idea too far with this comparison and one may be right. But, after all, what are human brains if not optimization machines? 
